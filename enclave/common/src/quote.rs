use std::io::{Cursor, Read, Seek, SeekFrom};
use std::str::FromStr;

use base64;
use byteorder::{LittleEndian, ReadBytesExt};
use serde_json;

use ekiden_common::error::{Error, Result};
use ekiden_common::hex_encoded_struct;

pub const QUOTE_CONTEXT_LEN: usize = 8;
pub type QuoteContext = [u8; QUOTE_CONTEXT_LEN];
/// Secure channel binding (EkQ-CoCl).
pub const QUOTE_CONTEXT_SC: QuoteContext = [69, 107, 81, 45, 67, 111, 67, 108];

// MRENCLAVE.
hex_encoded_struct!(MrEnclave, MRENCLAVE_LEN, 32);

/// Decoded quote body.
#[derive(Default, Debug)]
pub struct Body {
    version: u16,
    signature_type: u16,
    gid: u32,
    isv_svn_qe: u16,
    isv_svn_pce: u16,
    basename: [u8; 32],
}

/// Decoded quote report body.
#[derive(Default, Debug)]
pub struct ReportBody {
    cpu_svn: [u8; 16],
    misc_select: u32,
    attributes: [u8; 16],
    mr_enclave: MrEnclave,
    mr_signer: [u8; 32],
    isv_prod_id: u16,
    isv_svn: u16,
    report_data: Vec<u8>,
}

/// Decoded quote.
#[derive(Default, Debug)]
pub struct Quote {
    body: Body,
    report_body: ReportBody,
    signature: Vec<u8>,
}

impl Quote {
    /// Quote context offset.
    const CONTEXT_OFFSET: usize = 0;
    /// Quote context length.
    const CONTEXT_LENGTH: usize = 8;
    /// Report data public key offset.
    const PUBLIC_KEY_OFFSET: usize = 8;
    /// Report data public key length.
    const PUBLIC_KEY_LENGTH: usize = 32;
    /// Report data nonce offset.
    const NONCE_OFFSET: usize = 40;
    /// Report data nonce length.
    const NONCE_LENGTH: usize = 16;

    /// Decode quote.
    pub fn decode(quote: &Vec<u8>) -> Result<Quote> {
        let mut reader = Cursor::new(quote);
        let mut quote: Quote = Quote::default();

        // TODO: Should we ensure that reserved bytes are all zero?

        // Body.
        quote.body.version = reader.read_u16::<LittleEndian>()?;
        quote.body.signature_type = reader.read_u16::<LittleEndian>()?;
        quote.body.gid = reader.read_u32::<LittleEndian>()?;
        quote.body.isv_svn_qe = reader.read_u16::<LittleEndian>()?;
        quote.body.isv_svn_pce = reader.read_u16::<LittleEndian>()?;
        reader.seek(SeekFrom::Current(4))?; // 4 reserved bytes.
        reader.read_exact(&mut quote.body.basename)?;

        // Report body.
        reader.read_exact(&mut quote.report_body.cpu_svn)?;
        quote.report_body.misc_select = reader.read_u32::<LittleEndian>()?;
        reader.seek(SeekFrom::Current(28))?; // 28 reserved bytes.
        reader.read_exact(&mut quote.report_body.attributes)?;
        reader.read_exact(&mut quote.report_body.mr_enclave.0)?;
        reader.seek(SeekFrom::Current(32))?; // 32 reserved bytes.
        reader.read_exact(&mut quote.report_body.mr_signer)?;
        reader.seek(SeekFrom::Current(96))?; // 96 reserved bytes.
        quote.report_body.isv_prod_id = reader.read_u16::<LittleEndian>()?;
        quote.report_body.isv_svn = reader.read_u16::<LittleEndian>()?;
        reader.seek(SeekFrom::Current(60))?; // 60 reserved bytes.
        quote.report_body.report_data = vec![0; 64];
        reader.read_exact(&mut quote.report_body.report_data)?;

        // Signature.
        let signature_len = reader.read_u32::<LittleEndian>()? as usize;
        quote.signature = vec![0; signature_len];
        reader.read_exact(&mut quote.signature)?;

        Ok(quote)
    }

    /// Extract quote context from report data.
    ///
    /// This method assumes that the given report was generated by an Ekiden
    /// contract enclave, which provides the quote context in a specific location.
    pub fn get_quote_context(&self) -> &[u8] {
        &self.report_body.report_data
            [Quote::CONTEXT_OFFSET..Quote::CONTEXT_OFFSET + Quote::CONTEXT_LENGTH]
    }

    /// Extract public key from report data.
    ///
    /// This method assumes that the given report was generated by an Ekiden
    /// contract enclave, which provides the public key in a specific location.
    pub fn get_public_key(&self) -> &[u8] {
        &self.report_body.report_data
            [Quote::PUBLIC_KEY_OFFSET..Quote::PUBLIC_KEY_OFFSET + Quote::PUBLIC_KEY_LENGTH]
    }

    /// Extract nonce from report data.
    ///
    /// This method assumes that the given report was generated by an Ekiden
    /// contract enclave, which provides the nonce in a specific location.
    pub fn get_nonce(&self) -> &[u8] {
        &self.report_body.report_data
            [Quote::NONCE_OFFSET..Quote::NONCE_OFFSET + Quote::NONCE_LENGTH]
    }

    /// Extract MRENCLAVE from report body.
    pub fn get_mr_enclave(&self) -> &MrEnclave {
        &self.report_body.mr_enclave
    }
}

/// Attestation report.
#[derive(Default, Debug)]
pub struct AttestationReport {
    /// Raw report body (must be raw as the signature is computed over it). The body
    /// is JSON-encoded as per the IAS API specification.
    pub body: Vec<u8>,
    /// Report signature.
    pub signature: Vec<u8>,
    /// Report signing certificate chain in PEM format.
    pub certificates: Vec<u8>,
}

impl AttestationReport {
    pub fn new(body: Vec<u8>, signature: Vec<u8>, certificates: Vec<u8>) -> Self {
        AttestationReport {
            body: body,
            signature: signature,
            certificates: certificates,
        }
    }

    /// Verify attestation report.
    pub fn verify(&self) -> Result<()> {
        // TODO: Verify IAS signature.

        Ok(())
    }

    /// Decode quote from attestation report.
    ///
    /// If the quote cannot be verified, an error will be returned.
    pub fn get_quote(&self) -> Result<Quote> {
        self.verify()?;

        // Parse quote from body.
        let body: serde_json::Value = match serde_json::from_slice(self.body.as_slice()) {
            Ok(body) => body,
            _ => return Err(Error::new("Failed to parse report body")),
        };

        // TODO: Check timestamp, reject if report is too old (e.g. 1 day).

        let quote = match body["isvEnclaveQuoteBody"].as_str() {
            Some(quote) => quote,
            None => return Err(Error::new("Failed to parse quote")),
        };

        let quote = match base64::decode(&quote) {
            Ok(quote) => quote,
            _ => return Err(Error::new("Failed to parse quote")),
        };

        let quote = match Quote::decode(&quote) {
            Ok(quote) => quote,
            _ => return Err(Error::new("Failed to parse quote")),
        };

        // TODO: Verify enclave attributes.

        Ok(quote)
    }
}
