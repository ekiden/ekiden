---
apiVersion: v1
kind: Service
metadata:
  annotations:
    service.alpha.kubernetes.io/tolerate-unready-endpoints: "true"
  name: ekiden-token
  labels:
    app: ekiden-token
spec:
  ports:
    - port: 46656
      name: tendermint-p2p
  clusterIP: None
  selector:
    app: ekiden-token
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: tendermint-config
data:
  seeds: "ekiden-token-0,ekiden-token-1,ekiden-token-2,ekiden-token-3"
  validators: "ekiden-token-0,ekiden-token-1,ekiden-token-2,ekiden-token-3"
  validator.power: "10"
  genesis.json: |-
    {
      "genesis_time": "2018-01-25T00:00:00.000Z",
      "chain_id": "ekiden-token-test-net",
      "validators": [],
      "app_hash": ""
    }
  pub_key_nginx.conf: |-
    server {
      listen 80 default_server;
      listen [::]:80 default_server ipv6only=on;
      location /pub_key.json { root /usr/share/nginx/; }
    }
---
apiVersion: policy/v1beta1
kind: PodDisruptionBudget
metadata:
  name: ekiden-token-budget
spec:
  selector:
    matchLabels:
      app: ekiden-token
  minAvailable: 2
---
apiVersion: apps/v1beta2
kind: StatefulSet
metadata:
  name: ekiden-token
spec:
  selector:
    matchLabels:
      app: ekiden-token
  serviceName: ekiden-token
  replicas: 4
  template:
    metadata:
      labels:
        app: ekiden-token
    spec:
      initContainers:
        # An initialization container, which generates the validator key pair if it doesn't yet
        # exist. The public part is extracted and copied to /tendermint/pub_key.json, so it can
        # be served by the public-key container. This allows nodes to discover public keys of
        # each other.
        - name: generate-validator
          image: tendermint/tendermint:0.13.0
          imagePullPolicy: IfNotPresent
          command:
            - bash
            - "-c"
            - |
              set -ex
              if [ ! -f /tendermint/priv_validator.json ]; then
                tendermint gen_validator > /tendermint/priv_validator.json
                # pub_key.json will be served by public-key container
                cat /tendermint/priv_validator.json | jq ".pub_key" > /tendermint/pub_key.json
              fi
          volumeMounts:
            - name: tmdir
              mountPath: /tendermint

      containers:
        # Container serving the Tendermint node's public key.
        - name: public-key
          imagePullPolicy: IfNotPresent
          image: nginx:latest
          ports:
            - containerPort: 80
              name: public-key
          command:
            - bash
            - "-c"
            - |
              set -ex
              # fixes 403 Permission Denied (open() "/tendermint/pub_key.json" failed (13: Permission denied))
              # => we cannot serve from /tendermint, so we copy the file
              mkdir -p /usr/share/nginx
              cp /tendermint/pub_key.json /usr/share/nginx/pub_key.json
              nginx -g "daemon off;"
          volumeMounts:
            - name: tmdir
              mountPath: /tendermint
            - mountPath: /etc/nginx/conf.d/pub_key.conf
              name: tmconfigdir
              subPath: pub_key_nginx.conf

        # Container running a Tendermint node.
        - name: tendermint
          imagePullPolicy: IfNotPresent
          image: tendermint/tendermint:0.13.0
          ports:
            - containerPort: 46656
              name: tendermint-p2p
          env:
            - name: SEEDS
              valueFrom:
                configMapKeyRef:
                  name: tendermint-config
                  key: seeds
            - name: VALIDATOR_POWER
              valueFrom:
                configMapKeyRef:
                  name: tendermint-config
                  key: validator.power
            - name: VALIDATORS
              valueFrom:
                configMapKeyRef:
                  name: tendermint-config
                  key: validators
            - name: TMHOME
              value: /tendermint
          command:
            - bash
            - "-c"
            - |
              set -ex

              # Copy genesis file template.
              cp /etc/tendermint/genesis.json /tendermint/genesis.json

              # Fill genesis file with validators.
              IFS=',' read -ra VALS_ARR <<< "$VALIDATORS"
              fqdn_suffix=$(hostname -f | sed 's#[^.]*\.\(\)#\1#')
              for v in "${VALS_ARR[@]}"; do
                # Wait until validator generates priv/pub key pair.
                set +e

                curl -s --fail "http://$v.$fqdn_suffix/pub_key.json" > /dev/null
                ERR=$?
                while [ "$ERR" != 0 ]; do
                  sleep 5
                  curl -s --fail "http://$v.$fqdn_suffix/pub_key.json" > /dev/null
                  ERR=$?
                done
                set -e

                # Add validator to genesis file along with its pub_key.
                curl -s "http://$v.$fqdn_suffix/pub_key.json" | jq ". as \$k | {pub_key: \$k, power: $VALIDATOR_POWER, name: \"$v\"}" > pub_validator.json
                cat /tendermint/genesis.json | jq ".validators |= .+ [$(cat pub_validator.json)]" > tmpgenesis && mv tmpgenesis /tendermint/genesis.json
                rm pub_validator.json
              done

              # Construct seeds.
              IFS=',' read -ra SEEDS_ARR <<< "$SEEDS"
              seeds=()
              for s in "${SEEDS_ARR[@]}"; do
                seeds+=("$s.$fqdn_suffix:46656")
              done
              seeds=$(IFS=','; echo "${seeds[*]}")

              tendermint node \
                --p2p.seeds="$seeds" \
                --moniker="`hostname`" \
                --consensus.create_empty_blocks=false \
                --rpc.laddr tcp://0.0.0.0:46666 \
                --rpc.grpc_laddr tcp://0.0.0.0:46657

          volumeMounts:
            - name: tmdir
              mountPath: /tendermint
            - name: tmconfigdir
              mountPath: /etc/tendermint/genesis.json
              subPath: genesis.json

        # Container running an Ekiden consensus node.
        - name: consensus
          imagePullPolicy: Always
          image: ekiden/core:latest
          command:
            - bash
            - "-c"
            - |
              consensus \
                --tendermint-host localhost \
                --tendermint-port 46657 \
                --tendermint-abci-port 46658 \
                --grpc-port 9002

        # Container running an Ekiden key manager contract.
        - name: key-manager
          imagePullPolicy: Always
          image: ekiden/core:latest
          command:
            - bash
            - "-c"
            - |
              compute \
                --grpc-threads 4 \
                --port 9003 \
                --disable-key-manager \
                /ekiden/lib/key-manager.signed.so
          volumeMounts:
            - name: ias
              mountPath: /ias
              readOnly: true

        # Container running an Ekiden contract.
        - name: contract
          imagePullPolicy: Always
          image: ekiden/core:latest
          command:
            - bash
            - "-c"
            - |
              compute \
                --grpc-threads 4 \
                --port 9001 \
                --key-manager-host localhost \
                --key-manager-port 9003 \
                /ekiden/lib/token.signed.so
          volumeMounts:
            - name: ias
              mountPath: /ias
              readOnly: true

      volumes:
        - name: tmconfigdir
          configMap:
            name: tendermint-config
        - name: ias
          secret:
            secretName: ias


  volumeClaimTemplates:
    - metadata:
        name: tmdir
        annotations:
          volume.alpha.kubernetes.io/storage-class: anything
      spec:
        accessModes: ["ReadWriteOnce"]
        resources:
          requests:
            storage: 2Gi
---
# Proxy everything to one of the nodes. This is required because the key manager
# is currently stateless, so running things in different compute nodes makes them
# incompatible.
#
# When this is fixed, we can get rid of ekiden-token-proxy and use Kubernetes
# services directly (which does load balancing).
apiVersion: v1
kind: Service
metadata:
  annotations:
    service.alpha.kubernetes.io/tolerate-unready-endpoints: "true"
  name: ekiden-token-proxy
  labels:
    app: ekiden-token-proxy
spec:
  ports:
    - port: 9001
      name: ekiden-rpc
  type: NodePort
  selector:
    app: ekiden-token-proxy
---
apiVersion: apps/v1beta2
kind: Deployment
metadata:
  name: ekiden-token-proxy-deployment
  labels:
    app: ekiden-token-proxy
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ekiden-token-proxy
  template:
    metadata:
      labels:
        app: ekiden-token-proxy
    spec:
      containers:
        - name: proxy
          image: demandbase/docker-tcp-proxy
          ports:
            - containerPort: 9001
              name: ekiden-rpc
          env:
            - name: BACKEND_PORT
              value: "9001"
            - name: BACKEND_HOST
              value: ekiden-token-0.ekiden-token.default.svc.cluster.local
