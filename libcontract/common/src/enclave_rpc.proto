syntax = "proto3";

package enclave_rpc;

// Cryptographic secretbox (encrypted and authenticated).
message CryptoSecretbox {
    // Padded ciphertext.
    bytes ciphertext = 1;
    // Nonce.
    bytes nonce = 2;
}

// Cryptographic box (encrypted and authenticated).
message CryptoBox {
    // Nonce.
    bytes nonce = 1;
    // Encrypted and authenticated payload.
    bytes payload = 2;
    // Optional originator public key.
    bytes public_key = 3;
}

message PlainClientRequest {
    // Request method.
    string method = 1;
    // Payload (must be valid Protocol Buffers, based on given method).
    bytes payload = 2;
}

message ClientRequest {
    oneof request {
        // Plain-text request.
        PlainClientRequest plain_request = 1;
        // Encrypted request.
        CryptoBox encrypted_request = 2;
    }
}

message EnclaveRequest {
    // Starting state, encrypted (must decrypt to valid Protocol Buffers, based on contract).
    CryptoSecretbox encrypted_state = 1;
    // The part that comes from a client.
    ClientRequest client_request = 2;
}

message Error {
    // Error message.
    string message = 1;
}

message PlainClientResponse {
    enum Code {
        INVALID = 0;

        // 2xx indicades success.
        SUCCESS = 200;

        // 4xx indicates errors.
        ERROR = 400;
        ERROR_BAD_REQUEST = 401;
        ERROR_METHOD_NOT_FOUND = 402;
        ERROR_SECURE_CHANNEL = 403;
        ERROR_METHOD_SECURE = 404;
    }
    // Response code.
    Code code = 1;
    // Payload (must be valid Protocol Buffers, based on given method).
    bytes payload = 2;
}

message ClientResponse {
    oneof response {
        // Encrypted response.
        CryptoBox encrypted_response = 1;
        // Plain-text response.
        PlainClientResponse plain_response = 2;
    }
}

message EnclaveResponse {
    // New state, encrypted (must decrypt to valid Protocol Buffers, based on contract).
    CryptoSecretbox encrypted_state = 1;
    // The part that goes to a client.
    ClientResponse client_response = 2;
}

// Meta methods.
message MetadataRequest {
}

message MetadataResponse {
    // Contract name.
    string name = 1;
    // Contract version.
    string version = 2;
}

message ContractInitRequest {
}

message ContractInitResponse {
    // Public key used to establish a secure channel with the enclave. This
    // key is generated as part of the contract initialization process.
    bytes public_key = 1;
    // Sealed keys that should be persisted to the filesystem and used in
    // next enclave invocation.
    bytes sealed_keys = 2;
    // MRENCLAVE of the running contract. This is only used for convenience
    // to display it in the compute node when starting the contract.
    bytes mr_enclave = 3;
}

message ContractRestoreRequest {
    // Sealed keys if this enclave has previously been initialized.
    bytes sealed_keys = 1;
}

message ContractRestoreResponse {
    // Public key used to establish a secure channel with the enclave. This
    // key is generated as part of the contract initialization process.
    bytes public_key = 1;
}

message AttestationRequest {
    // 16-byte random nonce.
    bytes nonce = 1;
    // 16-byte SPID used for verifying remote attestation.
    bytes spid = 2;
}

message AttestationResponse {
    // Encoded signed attestation quote. This quote contains the public key
    // of the contract/client.
    bytes quote = 1;
}

message ChannelInitRequest {
    // Request for the contract to attest itself.
    AttestationRequest contract_attestation_request = 1;
    // 32-byte client short-term public key.
    bytes short_term_public_key = 2;
}

message ChannelInitResponseBox {
    // Server short-term public key.
    bytes short_term_public_key = 1;
    // Optional request for the client to attest itself. This is only set when
    // the contract requires the client to be an enclave. If this is set, the
    // client must call _channel_attest_client with the corresponding response.
    //
    // Until the client attests itself, the channel is not considered established
    // and calling any other method will fail.
    //
    // This cryptographic box contains an AttestationRequest message.
    AttestationRequest client_attestation_request = 2;
}

message ChannelInitResponse {
    // Contract attestation response.
    AttestationResponse contract_attestation_response = 1;
    // Encrypted ChannelInitResponseBox message.
    CryptoBox response_box = 2;
}

message ChannelAttestClientRequest {
    // Client attestation response.
    AttestationResponse client_attestation_response = 1;
}

message ChannelAttestClientResponse {
}

message ChannelCloseRequest {
}

message ChannelCloseResponse {
}

message StateDiffRequest {
    CryptoSecretbox old = 1;
    CryptoSecretbox new = 2;
}

message StateDiffResponse {
    CryptoSecretbox diff = 1;
}

message StateApplyRequest {
    CryptoSecretbox old = 1;
    CryptoSecretbox diff = 2;
}

message StateApplyResponse {
    CryptoSecretbox new = 1;
}
