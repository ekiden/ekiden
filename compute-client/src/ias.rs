use std::collections::HashMap;
use std::fs::File;
use std::io;
use std::io::{Cursor, Error, ErrorKind, Read, Seek, SeekFrom};
use std::str::FromStr;

use base64;
use byteorder::{LittleEndian, ReadBytesExt};
use reqwest;

/// Intel IAS API URL.
const IAS_API_URL: &'static str = "https://test-as.sgx.trustedservices.intel.com";
/// Intel IAS report endpoint.
const IAS_ENDPOINT_REPORT: &'static str = "/attestation/sgx/v2/report";

// SPID.
hex_encoded_struct!(SPID, SPID_LEN, 16);

// MRENCLAVE.
hex_encoded_struct!(MrEnclave, MRENCLAVE_LEN, 32);

/// IAS configuration.
///
/// The `spid` is a valid SPID obtained from Intel, while `pkcs12_archive`
/// is the path to the PKCS#12 archive (certificate and private key), which
/// will be used to authenticate to IAS.
pub struct IASConfiguration {
    /// SPID assigned by Intel.
    pub spid: SPID,
    /// PKCS#12 archive containing the identity for authenticating to IAS.
    pub pkcs12_archive: String,
}

/// IAS (Intel Attestation Service) interface.
pub struct IAS {
    /// SPID assigned by Intel.
    spid: SPID,
    /// Client used for IAS requests.
    client: Option<reqwest::Client>,
}

/// Decoded quote body.
#[derive(Default, Debug)]
pub struct Body {
    version: u16,
    signature_type: u16,
    gid: u32,
    isv_svn_qe: u16,
    isv_svn_pce: u16,
    basename: [u8; 32],
}

/// Decoded quote report body.
#[derive(Default, Debug)]
pub struct ReportBody {
    cpu_svn: [u8; 16],
    misc_select: u32,
    attributes: [u8; 16],
    mr_enclave: MrEnclave,
    mr_signer: [u8; 32],
    isv_prod_id: u16,
    isv_svn: u16,
    report_data: Vec<u8>,
}

/// Decoded quote.
#[derive(Default, Debug)]
pub struct Quote {
    body: Body,
    report_body: ReportBody,
    signature: Vec<u8>,
}

impl Quote {
    /// Report data public key offset.
    const PUBLIC_KEY_OFFSET: usize = 0;
    /// Report data public key length.
    const PUBLIC_KEY_LENGTH: usize = 32;
    /// Report data nonce offset.
    const NONCE_OFFSET: usize = 32;
    /// Report data nonce length.
    const NONCE_LENGTH: usize = 16;

    /// Extract public key from report data.
    ///
    /// This method assumes that the given report was generated by an Ekiden
    /// contract enclave, which provides the public key in a specific location.
    pub fn get_public_key(&self) -> &[u8] {
        &self.report_body.report_data[Quote::PUBLIC_KEY_OFFSET..Quote::PUBLIC_KEY_OFFSET + Quote::PUBLIC_KEY_LENGTH]
    }

    /// Extract nonce from report data.
    ///
    /// This method assumes that the given report was generated by an Ekiden
    /// contract enclave, which provides the nonce in a specific location.
    pub fn get_nonce(&self) -> &[u8] {
        &self.report_body.report_data[Quote::NONCE_OFFSET..Quote::NONCE_OFFSET + Quote::NONCE_LENGTH]
    }

    /// Get MRENCLAVE from report body.
    pub fn get_mr_enclave(&self) -> &MrEnclave {
        &self.report_body.mr_enclave
    }
}

impl IAS {
    /// Construct new IAS interface.
    pub fn new(config: Option<IASConfiguration>) -> io::Result<IAS> {
        Ok(IAS {
            spid: match config {
                Some(ref config) => config.spid.clone(),
                None => SPID([0; SPID_LEN])
            },
            client: match config {
                Some(IASConfiguration{spid: _, pkcs12_archive}) => {
                    // Read and parse PKCS#12 archive.
                    let mut buffer = Vec::new();
                    File::open(pkcs12_archive)?.read_to_end(&mut buffer)?;
                    let identity = match reqwest::Identity::from_pkcs12_der(&buffer, "") {
                        Ok(identity) => identity,
                        _ => return Err(Error::new(ErrorKind::Other, "Failed to load IAS credentials"))
                    };

                    // Create client with the identity.
                    let client = match {
                        reqwest::ClientBuilder::new()
                        .identity(identity)
                        .build()
                    } {
                        Ok(client) => client,
                        _ => return Err(Error::new(ErrorKind::Other, "Failed to create IAS client"))
                    };

                    Some(client)
                },
                None => None
            },
        })
    }

    /// Decode quote.
    pub fn decode_quote(quote: &Vec<u8>) -> io::Result<Quote> {
        let mut reader = Cursor::new(quote);
        let mut quote: Quote = Quote::default();

        // TODO: Should we ensure that reserved bytes are all zero?

        // Body.
        quote.body.version = reader.read_u16::<LittleEndian>()?;
        quote.body.signature_type = reader.read_u16::<LittleEndian>()?;
        quote.body.gid = reader.read_u32::<LittleEndian>()?;
        quote.body.isv_svn_qe = reader.read_u16::<LittleEndian>()?;
        quote.body.isv_svn_pce = reader.read_u16::<LittleEndian>()?;
        reader.seek(SeekFrom::Current(4))?; // 4 reserved bytes.
        reader.read_exact(&mut quote.body.basename)?;

        // Report body.
        reader.read_exact(&mut quote.report_body.cpu_svn)?;
        quote.report_body.misc_select = reader.read_u32::<LittleEndian>()?;
        reader.seek(SeekFrom::Current(28))?; // 28 reserved bytes.
        reader.read_exact(&mut quote.report_body.attributes)?;
        reader.read_exact(&mut quote.report_body.mr_enclave.0)?;
        reader.seek(SeekFrom::Current(32))?; // 32 reserved bytes.
        reader.read_exact(&mut quote.report_body.mr_signer)?;
        reader.seek(SeekFrom::Current(96))?; // 96 reserved bytes.
        quote.report_body.isv_prod_id = reader.read_u16::<LittleEndian>()?;
        quote.report_body.isv_svn = reader.read_u16::<LittleEndian>()?;
        reader.seek(SeekFrom::Current(60))?; // 60 reserved bytes.
        quote.report_body.report_data = vec![0; 64];
        reader.read_exact(&mut quote.report_body.report_data)?;

        // Signature.
        let signature_len = reader.read_u32::<LittleEndian>()? as usize;
        quote.signature = vec![0; signature_len];
        reader.read_exact(&mut quote.signature)?;

        Ok(quote)
    }

    /// Make authenticated web request to IAS.
    fn ias_request(&mut self, endpoint: &str, data: &HashMap<&str, String>) -> io::Result<reqwest::Response> {
        let endpoint = format!("{}{}", IAS_API_URL, endpoint);

        match self.client.as_ref().unwrap().post(&endpoint).json(&data).send() {
            Ok(response) => Ok(response),
            _ => return Err(Error::new(ErrorKind::Other, "Request to IAS failed"))
        }
    }

    /// Make authenticated web request to IAS report endpoint.
    fn ias_report(&mut self, quote: &Vec<u8>) -> io::Result<()> {
        if self.client.is_none() {
            // IAS verification disabled.
            return Ok(());
        }

        let mut request = HashMap::new();
        request.insert("isvEnclaveQuote", base64::encode(&quote));
        // TODO: Nonce?

        let response = self.ias_request(IAS_ENDPOINT_REPORT, &request)?;

        if response.status().is_success() {
            Ok(())
        } else {
            Err(Error::new(ErrorKind::Other, "IAS quote verification failed"))
        }
    }

    /// Verify quote via IAS and decode report data.
    pub fn verify_quote(&mut self, quote: &Vec<u8>) -> io::Result<Quote> {
        // Validate quote using IAS, abort if quote is invalid.
        self.ias_report(&quote)?;

        // Decode the valid quote.
        Ok(IAS::decode_quote(&quote)?)
    }

    /// Get configured SPID.
    pub fn get_spid(&self) -> &[u8; SPID_LEN] {
        &self.spid.0
    }
}
