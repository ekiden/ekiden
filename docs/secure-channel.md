# Secure Channel Protocol

## Keys
The following keys are maintained by the protocol:
* E - contract long-term public key pair, generated by libcontract in the secure enclave. The private part of this key pair only leaves the enclave in a sealed form, to be read on subsequent enclave restart.
* E' - contract short-term public key pair, generated by libcontract in the secure enclave for each client session.
* C' - client short-term public key pair, generated by the client before establishing a secure channel.

## State
The secure channel can be in one of the following states:
* `Init`
  Channel is being initialized (this is the initial state). After successful contract attestation, the channel will transition into:
    * `ClientAttestationRequired` if the contract requires the client to attset itself as well.
    * `Established` if no client attestation is required.
* `ClientAttestationRequired`
  Contract is waiting for client attestation. The channel may not be used for any method calls except `_channel_attest_client`. Any calls must be encrypted and authenticated with the short-term keys negotiated so far. The channel will transition into `Established` state if the client attestation is successful.
* `Established`
  Secure channel is established and may be used to make arbitrary method calls.

## Notation
`Box[X](C->E)` is a cryptographic box, encrypting and authenticating `X` from the client's public key `C` to the contract's public key `E`. The only people who can create or decipher `Box[X](C->E)` are the people who know the secret key corresponding to `C` and the people who know the secret key corresponding to `E`.

## Protocol
* The client begins by calling `_channel_init(nonce, spid, C')` where `nonce` is a nonce to be used during remote attestation, `spid` is the SPID that the client can use to verify the remote attestation and `C'` is the client short-term public key.
* The contract generates a `report(E, nonce, ...)`, which can be verified by the quoting enclave (`E` and `nonce` are embedded inside `report.data`). It uses this `report` to get a `quote` from the quoting enclave. The contract creates a new client session keyed by `C'` and generates key pair `E'`. The contract returns `(quote, Box[E', carq](E->C'))`, where `carq` is an optional client attestation request containing `(nonce, spid)` for cases, where the contract requires the client to attest itself.
* The client first verifies the `quote` by sending it to IAS. If the quote is valid, has the correct `nonce`, is for the correct `mrenclave` and has the correct attributes, the client proceeds to decode the quote, obtaining `E`. Then it can open the received cryptographic box to obtain `E'`.
* From this point forward, for each request, the client transmits `(C', Box[request](C'->E')`, where `request` is a properly serialized request.
* From this point forward, for each response, the server transmits `(Box[response](E'->C'))` where `response` is a properly serialized response.
* If the contract does not require client attestation, the channel is now established.
* If the contract requires client attestation, the client will generate a `report(C', nonce, ...)` and get a `quote` from the quoting enclave. The client will then call `_channel_attest_client(quote)`.
* The contract will first verify the quote via IAS. If the quote is valid, has the correct `nonce`, short-term public key `C'` and has the correct attributes, client attestation succeeds (client's MRENCLAVE is established).

## Nonces
While not explicitly mentioned above, each cryptographic box also contains a 24-byte nonce. Each nonce contains a 16-byte "nonce context" prefix, which prevents the message from being used in a different context. The following 8-bytes are generated based on the kind of message.

Where long-term keys are involved (only the channel initialization messages), the nonces are generated using a cryptographically secure random generator.

Where short-term keys are involved (unique for each session), the nonces are generated using a monotonically increasing counter. Both the client and the contract verify that each following nonce is greater than the last. This prevents message replays.

## Cryptography
The protocol uses NaCl primitives (e.g. the authenticated encryption is implemented using Curve25519, Salsa20, and Poly1305).