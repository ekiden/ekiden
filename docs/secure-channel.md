# Secure Channel Protocol

## Keys
The following keys are maintained by the protocol:
* E - contract long-term public key pair, generated by libcontract in the secure enclave. The private part of this key pair only leaves the enclave in a sealed form, to be read on subsequent enclave restart.
* E' - contract short-term public key pair, generated by libcontract in the secure enclave for each client session.
* AE - enclave attestation report,  refreshed periodically from IAS, which binds the enclave identity (MRENCLAVE) to the long-term public key E.
* C' - client short-term public key pair, generated by the client before establishing a secure channel.
* AC' - client attestation report, which binds the client enclave identity (MRENCLAVE) to the short-term public key C'.

## State
The secure channel can be in one of the following states:
* `Init`
  Channel is being initialized (this is the initial state). After successful contract attestation, the channel will transition into `Established` state.
* `Established`
  Secure channel is established and may be used to make arbitrary method calls.

## Notation
`Box[X](C->E)` is a cryptographic box, encrypting and authenticating `X` from the client's public key `C` to the contract's public key `E`. The only people who can create or decipher `Box[X](C->E)` are the people who know the secret key corresponding to `C` and the people who know the secret key corresponding to `E`.

## Protocol
* The client begins by calling `_channel_init(C', AC')` where `C'` is the client short-term public key. If the contract requires client attestation, the client also provides `AC'`.
* If client attestation is required, the contract first verifies `AC'`, decodes the quote and ensures `C'` matches. Then, the contract creates a new client session keyed by `C'` and generates key pair `E'`. The contract returns `(AE, Box[E'](E->C'))`.
* The client first verifies `AE` and decodes the quote, obtaining `E`. Then it can open the received cryptographic box to obtain `E'`.
* From this point forward, for each request, the client transmits `(C', Box[request](C'->E')`, where `request` is a properly serialized request.
* From this point forward, for each response, the server transmits `(Box[response](E'->C'))` where `response` is a properly serialized response.
* The channel is now established.

## Nonces
While not explicitly mentioned above, each cryptographic box also contains a 24-byte nonce. Each nonce contains a 16-byte "nonce context" prefix, which prevents the message from being used in a different context. The following 8-bytes are generated based on the kind of message.

Where long-term keys are involved (only the channel initialization messages), the nonces are generated using a cryptographically secure random generator.

Where short-term keys are involved (unique for each session), the nonces are generated using a monotonically increasing counter. Both the client and the contract verify that each following nonce is greater than the last. This prevents message replays.

## Cryptography
The protocol uses NaCl primitives (e.g. the authenticated encryption is implemented using Curve25519, Salsa20, and Poly1305).